#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Error function used for reporting issues
void error(const char *msg) {
  perror(msg);
  exit(1);
} 

// Set up the address struct for the server socket
void setupAddressStruct(struct sockaddr_in* address, 
                        int portNumber){
 
  // Clear out the address struct
  memset((char*) address, '\0', sizeof(*address)); 

  // The address should be network capable
  address->sin_family = AF_INET;
  // Store the port number
  address->sin_port = htons(portNumber);
  // Allow a client at any address to connect to this server
  address->sin_addr.s_addr = INADDR_ANY;
}

int main(int argc, char *argv[]){
  int connectionSocket, charsRead;
  char buffer[256];
  struct sockaddr_in serverAddress, clientAddress;
  socklen_t sizeOfClientInfo = sizeof(clientAddress);

  // Check usage & args
  if (argc < 2) { 
    fprintf(stderr,"USAGE: %s port\n", argv[0]); 
    exit(1);
  } 
  
  // Create the socket that will listen for connections
  int listenSocket = socket(AF_INET, SOCK_STREAM, 0);
  if (listenSocket < 0) {
    error("ERROR opening socket");
  }

  // Set up the address struct for the server socket
  setupAddressStruct(&serverAddress, atoi(argv[1]));

  // Associate the socket to the port
  if (bind(listenSocket, 
          (struct sockaddr *)&serverAddress, 
          sizeof(serverAddress)) < 0){
    error("ERROR on binding");
  }

  // Start listening for connetions. Allow up to 5 connections to queue up
  listen(listenSocket, 5); 
  
  // Accept a connection, blocking if one is not available until one connects
  while(1){
    // Accept the connection request which creates a connection socket
    connectionSocket = accept(listenSocket, 
                (struct sockaddr *)&clientAddress, 
                &sizeOfClientInfo); 
    if (connectionSocket < 0){
      error("ERROR on accept");
    }

    printf("SERVER: Connected to client running at host %d port %d\n", 
                          ntohs(clientAddress.sin_addr.s_addr),
                          ntohs(clientAddress.sin_port));

    // Get the message from the client and display it
    // memset(buffer, '\0', 256);
    // // Read the client's message from the socket
    // charsRead = recv(connectionSocket, buffer, 255, 0); 
    // if (charsRead < 0){
    //   error("ERROR reading from socket");
    // }
    // printf("SERVER: I received this from the client: \"%s\"\n", buffer);
   

   // Receive plaintext size from client
  char clientelcharsizestr[4];
  memset(clientelcharsizestr, '\0', 4);
  /*
  This is where wee are connecting directly to the client through the recv function thats recieving something through the socket that is being sent.
  */
  charsRead = recv(connectionSocket, clientelcharsizestr, 3, 0);
  /*
  check to see if you actually got something from the client.
  */
 if (charsRead < 0){
  error("Error reading from the socket");
  //meaning u got nara.
 }
 /*
 Remember how you made plain text a string.Now first convert it to an integer so it knows what to expect.
 */
int clientelsize= atoi(clientelcharsizestr);
/*
Next step is to check if it has been converted.
*/
if (clientelsize == 0 && clientelcharsizestr[0] != '0'){
  error("Error converting integer");
}
/*
allocating of memory for the plaintext and using a pointer to point where it will staart from.
*/
char *plaintext = malloc(clientelsize + 1);
if (plaintext == NULL){
  error("error allocating memory for plaintext");
}
memset(plaintext, '\0', clientelsize + 1);
int totalcharsread =0;
while(totalcharsread < clientelsize){
charsRead = recv(connectionSocket, plaintext, clientelsize, 0);
if (charsRead < 0){
  error("Error reading from socket");
}
totalcharsread += charsRead;
}
printf("SERVER: I received this from the client: \"%s\"\n", plaintext);

char keysizestr[4];
memset(keysizestr, '\0', 4);
charsRead = recv(connectionSocket, keysizestr, 3,0);
// meaning no keysize string was sent over from the client.
if (charsRead < 0){
  error("Error reading from socket");
}
// if u found it do urself a favor and conver it to an integer.This will help in knowing how many number of keys to expect.
int keysize = atoi(keysizestr);
if (keysize ==0 && keysizestr[0] != '0'){
  error("Error converting integer");
}
// otherwise if keysize was sent chances are that were gonne a need  to allocate memory for our keys.I think dynamically.
char *actualkeys= malloc(keysize + 1);
// checking if memory was allocated for our keys.
if (actualkeys == NULL){
  error("error allocating memory for the keys ");
}
memset(actualkeys, '\0', keysize + 1);
charsRead = recv(connectionSocket, actualkeys,keysize,0);
// checki if any keys were recieved from our connection.
if (charsRead < 0){
  error("Error reading information from the socket");
}
printf("SERVER I RECIEVED THIS FROM THE CLIENT: \"%s\"\n", actualkeys);
free(plaintext);
free(actualkeys);
















// // Receive key size from client
// char keySizeStr[4];
// memset(keySizeStr, '\0', 4);
// charsRead = recv(connectionSocket, keySizeStr, 3, 0); 
// if (charsRead < 0){
//   error("ERROR reading from socket");
// }

// // Convert key size to integer
// int keySize = atoi(keySizeStr);
// if (keySize == 0 && keySizeStr[0] != '0'){
//   error("Error converting integer");
// }

// // Allocate memory for the key
// char *key = malloc(keySize + 1);
// if (key == NULL){
//   error("Error allocating memory for key");
// }

// // Receive the key from the client
// memset(key, '\0', keySize + 1);
// charsRead = recv(connectionSocket, key, keySize, 0); 
// if (charsRead < 0){
//   error("ERROR reading from socket");
// }

// printf("SERVER: I received this key from the client: \"%s\"\n", key);

// // Don't forget to free the memory when you're done with it
// free(plaintext);
// free(key);




    // Send a Success message back to the client
    charsRead = send(connectionSocket, 
                    "I am the server, and I got your message", 39, 0); 
    if (charsRead < 0){
      error("ERROR writing to socket");
    }
    // Close the connection socket for this client
    close(connectionSocket); 
  }
  // Close the listening socket
  close(listenSocket); 
  return 0;
}

